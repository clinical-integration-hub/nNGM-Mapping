/// version = 0.1
/// title = "nNGM: nNGMv09c - FHIR to CTS"

map "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_CdsToFhir_Master" = nNGM_Mapping_CdsToFhir_Master

uses "http://hl7.org/fhir/StructureDefinition/CTS_Transport" as source
uses "http://hl7.org/fhir/StructureDefinition/Bundle" as target


// Stammdaten
imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_StammdatenFHIR"

// Antrag
imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_BasisangabenFHIR"
imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_Anforderung"
imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_TNMFHIR"
imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_ResistenztestungFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_VorbefundFHIR"

// Befund
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_ImmunhistochemieFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_HistologieFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_MolekularphatologieFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_NGSLungPanelFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_FusionNGSFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_FastTrackFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_SonstigeUntersuchungenFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_LiquidBiopsyFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nnGM_Mapping_BeurteilungFHIR"

// Therapien
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_StrahlentherapieFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_SonstigeTherapieFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_OperationTherapieFHIR"
// imports "http://uk-koeln.de/fhir/StructureMap/nNGM_Mapping_SystemischeTherapieFHIR"

group MapCDS(source src: CTS_Transport, target tgt: Bundle)
{
    // Bundle metadata
    src -> tgt.id = uuid();
    src -> tgt.type = 'collection';

    src then MapStammdaten(src, tgt);
    src then MapAntrag(src, tgt);
    // TODO
    // src then MapBefund(src, tgt);
    // TODO
    // src then MapTherapies(src, tgt);
    src then MapTNM(src, tgt);
}

/* ------------------------------ Stammdaten ---------------------------- */
group MapStammdaten(source src: CTS_Transport, target tgt: Bundle)
{
    src.operations as operations, operations where "crfid = 'SD' and type = 'save'" ->
        tgt.entry as entry,
        entry.resource = create('Bundle') as bundleStammdaten,
        bundleStammdaten.entry as entryStammdaten,
        entryStammdaten.resource = create('Composition') as compositionStammdaten then
    {
        /* ------------------------------ Bundle ---------------------------- */

        // Meta
        src -> bundleStammdaten.id = uuid();
        src -> bundleStammdaten.type = 'transaction';

        /* ------------------------------ Composition ---------------------------- */

        // Meta
        src -> compositionStammdaten.title = 'Stammdaten pseudonymisiert';
        src -> compositionStammdaten.id = uuid();
        src -> compositionStammdaten.meta as meta collate, meta.profile = 'http://uk-koeln.de/fhir/StructureDefinition/Composition/nNGM/Stammdaten-pseudonymisiert';
        src -> compositionStammdaten.status = cast('final', 'FHIR.code');

        // Request
        src -> entryStammdaten.request as request, request.method = 'PUT', request.url = evaluate(compositionStammdaten, '\'Composition/\' + $this.id');

        // Type
        src -> compositionStammdaten.type = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/compositions', 'stammdaten');

        // Category idat or not idat
        src -> compositionStammdaten.category = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/composition-category', 'psn');

        // Subject
        operations.data as data, data.values as values where "blockindex = 0 and groupindex = 0 and itemid = 'uuid_nngm_patient'" then
        {
            src.patid as patid, values.value as value -> compositionStammdaten.subject = create('Reference') as subject, subject.reference = value, subject.identifier as identifier, identifier.system = 'http://uk-koeln.de/fhir/NamingSystem/nNGM/patient-identifier', identifier.value = patid;
        };

        // Date
        operations.timestamp as timestamp -> compositionStammdaten.date = dateOp(timestamp, 'dateTime');

        // Author 
        operations.editor as author -> compositionStammdaten.author as author, author.extension as dataAbsentReason, dataAbsentReason.url = 'http://hl7.org/fhir/StructureDefinition/data-absent-reason', dataAbsentReason.valueCode = cast('not-asked', 'FHIR.code'); 
            
        /* ------------------------------ Resources ---------------------------- */
        operations then TransformBundleStammdaten(operations, bundleStammdaten, compositionStammdaten);
    };
}

/* ------------------------------ Antrag ---------------------------- */
group MapAntrag(source src: CTS_Transport, target tgt: Bundle)
{
    let index = create('RepeatIndex');

    src then InitCaseIndex(src, index); // Reset caseIndex
    src then InitMaxIndexAntrag(src, index); // Reset maxIndex

    src.operations as operations,
        // Execute as many times as there are Basisangaben
        operations where "crfid = %index.caseIndex.toString() + '-BA' and type = 'save'  and data.exists()" ->
        // Add a transaction bundle to the collection bundle
        tgt.entry as entry,
        entry.resource = create('Bundle') as bundleAntrag,
        // Add a composition to the transaction bundle
        bundleAntrag.entry as entryAntrag,
        entryAntrag.resource = create('Composition') as compositionAntrag then
    {
        // Create this let because we can't check on two parameters with the same name in FHIRPath
        let caseIndex = evaluate(index, '$this.caseIndex');
        let maxIndex = evaluate(index, '$this.maxIndex');

        /* ------------------------------ Bundle ---------------------------- */

        // Meta
        src -> bundleAntrag.id = uuid();
        src -> bundleAntrag.type = 'transaction';

        /* ------------------------------ Composition ---------------------------- */

        // Meta
        src -> compositionAntrag.title = 'nNGM - Antrag Pseudonymisiert';
        src -> compositionAntrag.id = uuid();
        src -> compositionAntrag.meta as meta collate, meta.profile = 'http://uk-koeln.de/fhir/StructureDefinition/Composition/nNGM/Antrag-pseudonymisiert';
        src -> compositionAntrag.status = cast('final', 'FHIR.code');
        src -> entryAntrag.request as request, request.method = 'PUT', request.url = evaluate(compositionAntrag, '\'Composition/\' + $this.id');

        // Identifier i.e. Case ID
        src -> compositionAntrag.identifier = create('Identifier') as FallIdentifier,
                                                    FallIdentifier.system = 'http://uk-koeln.de/NamingSystem/nNGM/fallnummer',
                                                    FallIdentifier.value = evaluate(index, '$this.caseIndex.toString()');

        // Type check for type of content
        src -> compositionAntrag.type = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/compositions', 'antrag');

        // Category idat or not idat
        src -> compositionAntrag.category = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/composition-category', 'psn');

        // Subject
        src.operations as operations, operations where "crfid = 'SD'", operations.data as data, data.values as values where "blockindex = 0 and groupindex = 0 and itemid = 'uuid_nngm_patient'" then
        {
            src.patid as patid, values.value as value -> compositionAntrag.subject = create('Reference') as subject, subject.reference = value, subject.identifier as identifier, identifier.system = 'http://uk-koeln.de/fhir/NamingSystem/nNGM/patient-identifier', identifier.value = patid;
        };

        // Date
        operations.timestamp as timestamp -> compositionAntrag.date = dateOp(timestamp, 'dateTime');

        // Author
        operations.editor as author -> compositionAntrag.author = create('Reference') as subject, subject.reference = author;

        /* ------------------------------ Resources ---------------------------- */

        // Basisangaben (Antrag.basisangaben)
        src.operations as operations, operations where "crfid = %caseIndex.toString() + '-BA' and type = 'save'  and data.exists()" then
        {
            src then TransformBundleBasisangaben(operations, bundleAntrag, compositionAntrag);
        };

        // Biopsie(n) (Antrag.biopsie) (Create one biopsy section per biopsie)
        src then InitFormIndex(src, index); // the formIndex indicates which biopsie (an thus which biopsieSection) should be created
        src.operations as operations, operations where "%index.formIndex <= %maxIndex" -> compositionAntrag.section = create('BackboneElement') as biopsieSection then
        {
            /* ------------------------------ Section ---------------------------- */
            // Meta
            src -> biopsieSection.title = 'biopsy';
            src -> biopsieSection.code = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/sections','biopsie');
            src -> biopsieSection.entry = create('Reference') as reference, reference.identifier = create('Identifier') as formularId,
                                                formularId.system = 'http://uk-koeln.de/NamingSystem/nNGM/formularId',
                                                formularId.value = evaluate(index, '$this.formIndex.toString()');

            /* ------------------------------ Resources ---------------------------- */
            // Anforderung (Antrag.biopsie.anforderung)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-AF' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                src then TransformBundleAnforderung(operations, bundleAntrag, compositionAntrag, biopsieSection);
            };

            // TNM (Antrag.biopsie.tnm)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-TNM' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                src then TransformBundleTNM(operations, bundleAntrag, compositionAntrag, biopsieSection);
            };

            // Resistenztestung (Antrag.biopsie.resistenztestung)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-RT' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                src then TransformBundleResistenztestung(operations, bundleAntrag, compositionAntrag, biopsieSection);
            };

            // // Vorbefund (Antrag.biopsie.vorbefund)
            // src.operations as operations, operations where "crfid = %caseIndex.toString() + '-VB' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            // {
            //     src then TransformBundleVorbefundFHIR(operations, bundleAntrag, compositionAntrag, biopsieSection, index);
            // };

            src then IncrementFormIndex(src, index);
        };

        /* ------------------------------ Increment index ---------------------------- */
        src then IncrementCaseIndex(src, index);
        src then InitMaxIndexAntrag(src, index); // Reset maxIndex
    };
}

// TODO
group MapBefund(source src: CTS_Transport, target tgt: Bundle)
{
    let index = create('RepeatIndex');

    /* ------------------------------ Befund ---------------------------- */
    src then InitCaseIndex(src, index); // Reset caseIndex
    src then InitMaxIndexBefund(src, index); // Reset maxIndex

    src.operations as operations,
    // Execute as many times as there are Basisangaben
    operations where "crfid = %index.caseIndex.toString() + '-BA' and type = 'save'  and data.exists()" ->
    // Add a transaction bundle to the collection bundle
    tgt.entry as entry,
    entry.resource = create('Bundle') as bundleBefund,
    // Add a composition to the transaction bundle
    bundleBefund.entry as entryBefund,
    entryBefund.resource = create('Composition') as compositionBefund then
    {
        // Create this let because we can't check on two parameters with the same name in FHIRPath
        let caseIndex = evaluate(index, '$this.caseIndex');
        let maxIndex = evaluate(index, '$this.maxIndex');

        /* ------------------------------ Bundle ---------------------------- */
        // Meta
        src -> bundleBefund.id = uuid();
        src -> bundleBefund.type = 'transaction';

        /* ------------------------------ Composition ---------------------------- */
        // Meta
        src -> compositionBefund.id = uuid();
        src -> compositionBefund.meta as meta collate, meta.profile = 'http://uk-koeln.de/fhir/StructureDefinition/Composition/nNGM/molpatho-befund-pseudonymisiert';
        src -> compositionBefund.type = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/compositions', 'molpatho-befund');

        // Category idat or psn depends on which type of patient/consent is in the bundle
        src -> compositionBefund.category = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/composition-category', 'psn');

        // Title
        src -> compositionBefund.title = 'Befund Pseudonymisiert';

        // Identifier i.e. Case ID
        src -> compositionBefund.identifier = create('Identifier') as FallIdentifier,
                                                    FallIdentifier.system = 'http://uk-koeln.de/NamingSystem/nNGM/fallnummer',
                                                    FallIdentifier.value = evaluate(index, '$this.caseIndex.toString()');

        // Status
        src -> compositionBefund.status = cast('final', 'FHIR.code');

        // Subject
        src.operations as operations, operations where "crfid = 'SD'", operations.data as data, data.values as values where "blockindex = 0 and groupindex = 0 and itemid = 'uuid_nngm_patient'" then
        {
            src.patid as patid, values.value as value -> compositionBefund.subject = create('Reference') as subject, subject.reference = value, subject.identifier as identifier, identifier.system = 'http://uk-koeln.de/fhir/NamingSystem/nNGM/patient-identifier', identifier.value = patid;
        };

        // Date
        operations.timestamp as timestamp -> compositionBefund.date = dateOp(timestamp, 'dateTime');

        // Author
        operations.editor as author -> compositionBefund.author = create('Reference') as subject, subject.reference = author;

        /* ------------------------------ Resources ---------------------------- */

        // Diagnostik(en) (Befund.diagnostik)
        // create 1 diagnosticSection per diagnostik (in the CDS)
        src then InitFormIndex(src, index); // the formIndex indicates which diagnostik (an thus which diagnosticSection) should be created
        src.operations as operations, operations where "%index.formIndex <= %maxIndex" -> compositionBefund.section = create('BackboneElement') as diagnosticSection then
        {
            /* ------------------------------ Section ---------------------------- */
            // Meta
            src -> diagnosticSection.title = 'diagnostik';
            src -> diagnosticSection.code = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/sections','diagnostik');
            src -> diagnosticSection.entry = create('Reference') as reference, reference.identifier = create('Identifier') as formularId,
                                                formularId.system = 'http://uk-koeln.de/NamingSystem/nNGM/formularId',
                                                formularId.value = evaluate(index, '$this.formIndex.toString()');

            /* ------------------------------ Resources ---------------------------- */
            // Immunhistochemie (Befund.diagnostik.immunhistochemie)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-IHC' + %index.formIndex.toString() and type = 'save' and data.exists()" then
            {
                src then TransformBundleImmunhistochemie(operations, bundleBefund, compositionBefund, diagnosticSection);
                src then SetReferenceToAnforderungSpecimen(tgt, bundleBefund, compositionBefund, diagnosticSection);
            };

            // Histologie (Befund.diagnostik.histologie)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-HL' + %index.formIndex.toString() and type = 'save' and data.exists()" then
            {
                src then TransformBundleHistologie(operations, bundleBefund, compositionBefund, diagnosticSection);
            };

            // Molekularpathologie (Befund.diagnostik.molekularpathologie)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-MP' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                src then TransformBundleMolekularpathologie(operations, bundleBefund, compositionBefund, diagnosticSection);
                src then SetReferenceToAnforderungSpecimen(tgt, bundleBefund, compositionBefund, diagnosticSection);
            };

            // NGS Lung Panel (Befund.diagnostik.ngs-lung-panel)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-LP' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                src then TransformBundleNGSLungPanel(operations, bundleBefund, compositionBefund, diagnosticSection, index);
                src then SetReferenceToAnforderungSpecimen(tgt, bundleBefund, compositionBefund, diagnosticSection);
            };

            // Fusion NGS (Befund.diagnostik.ngs-fusion-expression)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-FS' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                src then TransformBundleFusionNGS(operations, bundleBefund, compositionBefund, diagnosticSection, index);
                src then SetReferenceToAnforderungSpecimen(tgt, bundleBefund, compositionBefund, diagnosticSection);
            };

            // Fast Track (Befund.diagnostik.fast-track)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-FT' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                src then TransformBundleFastTrack(operations, bundleBefund, compositionBefund, diagnosticSection);
                src then SetReferenceToAnforderungSpecimen(tgt, bundleBefund, compositionBefund, diagnosticSection);
            };

            // Sonstige Untersuchungen (Befund.diagnostik.sonstige-untersuchungen)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-SU' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                src then TransformBundleSonstigeUntersuchungen(operations, bundleBefund, compositionBefund, diagnosticSection, index);
                src then SetReferenceToAnforderungSpecimen(tgt, bundleBefund, compositionBefund, diagnosticSection);
            };
            
            // Liquid Biopsy (Befund.diagnostik.liquid-biopsy)
            src.operations as operations, operations where "crfid = %caseIndex.toString() + '-LB' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                src then TransformBundleLiquidBiopsy(operations, bundleBefund, compositionBefund, diagnosticSection, index);
                src then SetReferenceToAnforderungSpecimen(tgt, bundleBefund, compositionBefund, diagnosticSection);
            };

            src then IncrementFormIndex(src, index);
        };

        // Beurteilung (Befund.beurteilung)
        src.operations as operations, operations where "crfid = %caseIndex.toString() + '-BU' and type = 'save'  and data.exists()" then
        {
            src then TransformBundleBeurteilung(operations, bundleBefund, compositionBefund, index);
        };

        /* ------------------------------ Increment index ---------------------------- */
        src then IncrementCaseIndex(src, index);
        src then InitMaxIndexBefund(src, index); // Reset maxIndex
    };
}

// TODO
group MapTherapies(source src: CTS_Transport, target tgt: Bundle)
{
    let index = create('RepeatIndex');

    /* ------------------------------ Therapien ---------------------------- */
    src then InitCaseIndex(src, index); // Reset index
    src ->
    // Add a transaction bundle to the collection bundle
    tgt.entry as entry,
    entry.resource = create('Bundle') as bundleTherapie,
    // Add a composition to the transaction bundle
    bundleTherapie.entry as entryTherapie,
    entryTherapie.resource = create('Composition') as compositionTherapie then
    {
        /* ------------------------------ Bundle ---------------------------- */

        // Meta
        src -> bundleTherapie.id = uuid();
        src -> bundleTherapie.type = 'transaction';


        /* ------------------------------ Composition ---------------------------- */

        // Meta
        src -> compositionTherapie.id = uuid();
        src -> compositionTherapie.meta as meta collate, meta.profile = 'http://uk-koeln.de/fhir/StructureDefinition/Composition/nNGM/Therapie-pseudonymisiert';
        src -> compositionTherapie.type = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/compositions', 'therapie');

        // Category idat or psn depends on which type of patient/consent is in the bundle
        src -> compositionTherapie.category = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/composition-category', 'psn');

        // Title
        src -> compositionTherapie.title = 'Therapie pseudonymisiert';

        // Identifier i.e. Case ID
        src -> compositionTherapie.identifier as identifier, identifier.value = 1;

        // Status
        src -> compositionTherapie.status = cast('final', 'FHIR.code');

        // Subject
        src.operations as operations, operations where "crfid = 'SD'", operations.data as data, data.values as values where "blockindex = 0 and groupindex = 0 and itemid = 'uuid_nngm_patient'" then
        {
            src.patid as patid, values.value as value -> compositionTherapie.subject = create('Reference') as subject, subject.reference = value, subject.identifier as identifier, identifier.system = 'http://uk-koeln.de/fhir/NamingSystem/nNGM/patient-identifier', identifier.value = patid;
        };

        // TODO: which timestamp and author to use? the one of Stammdaten or the first Basisangaben?
        // Date
        // operations.timestamp as timestamp -> compositionTherapie.date = dateOp(timestamp, 'dateTime');

        // Author
        // operations.editor as author -> compositionTherapie.author = create('Reference') as subject, subject.reference = author;

        /* ------------------------------ Section ---------------------------- */

        src -> compositionTherapie.section = create('BackboneElement') as sectionTherapie, sectionTherapie.code = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/sections', 'therapie') then
        {
            /* ------------------------------ Therapie ---------------------------- */

            // Operation
            src then InitFormIndex(src, index);
            src.operations as operations, operations where "crfid = 'OP' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                // src then TransformBundleOperationTherapie(operations, bundleTherapie, compositionTherapie, sectionTherapie);
                src then IncrementFormIndex(src, index);
            };

            // SystemischeTherapie
            src then InitFormIndex(src, index);
            src.operations as operations, operations where "crfid = 'SY' + %index.formIndex.toString() and type = 'save'  and data.exists()" then
            {
                src then TransformBundleSystemischeTherapie(operations, bundleTherapie, compositionTherapie, sectionTherapie);
                src then IncrementFormIndex(src, index);
            };
        };
    };
}

/* ------------------------------ TNM ---------------------------- */
group MapTNM(source src: CTS_Transport, target tgt: Bundle)
{
    let index = create('RepeatIndex');

    src then InitMaxIndexTNM(src, index); // Reset maxIndex

    /* ------------------------------ TNM ---------------------------- */
    src ->
    // Add a transaction bundle to the collection bundle
    tgt.entry as entry,
    entry.resource = create('Bundle') as bundleTNM,
    // Add a composition to the transaction bundle
    bundleTNM.entry as entryTNM, 
    entryTNM.resource = create('Composition') as compositionTNM then
    {
        let maxIndex = evaluate(index, '$this.maxIndex');

        /* ------------------------------ Bundle ---------------------------- */

        // Meta
        src -> bundleTNM.id = uuid();
        src -> bundleTNM.type = 'transaction';

        /* ------------------------------ Composition ---------------------------- */

        // Meta
        src -> compositionTNM.id = uuid();
        src -> compositionTNM.meta as meta collate, meta.profile = 'http://uk-koeln.de/fhir/StructureDefinition/Composition/nNGM/TNM-pseudonymisiert';
        src -> entryTNM.request as request, request.method = 'PUT', request.url = evaluate(compositionTNM, '\'Composition/\' + $this.id');
        
        // Type
        src -> compositionTNM.type = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/compositions', 'tnm');

        // Category idat or psn depends on which type of patient/consent is in the bundle
        src -> compositionTNM.category = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/composition-category', 'psn');

        // Title
        src -> compositionTNM.title = 'TNM Pseudonymisiert';

        // Status
        src -> compositionTNM.status = cast('final', 'FHIR.code');

        // Subject
        src.operations as operations, operations.data as data, data.values as values where "blockindex = 0 and groupindex = 0 and itemid = 'uuid_nngm_patient'" then
        {
            src.patid as patid, values.value as value -> compositionTNM.subject = create('Reference') as subject, subject.reference = value, subject.identifier as identifier, identifier.system = 'http://uk-koeln.de/fhir/NamingSystem/nNGM/patient-identifier', identifier.value = patid;
        };

        // Date
        src.operations as operations, operations.timestamp as timestamp -> compositionTNM.date = dateOp(timestamp, 'dateTime');

        // Author
        src.operations as operations, operations.editor as author -> compositionTNM.author as subject collate, subject.reference = author;
        
        /* ------------------------------ Section ---------------------------- */
        src then InitFormIndex(src, index);
        src.operations as operations, operations where "%index.formIndex <= %maxIndex" -> compositionTNM.section as compositionSection then
        {
            src.operations as operations,
                    operations where "crfid = 'TNM' + %index.formIndex.toString() and type = 'save'" -> 
                    compositionTNM.section = create('BackboneElement') as section,
                    section.title = 'TNM',
                    section.code = cc('http://uk-koeln.de/fhir/CodeSystem/nngm/sections', 'tnm') then
            {
                operations then CreateObservationTNM(operations, bundleTNM, compositionTNM, section);
                operations -> section.entry = create('Reference') as reference,
                    reference.identifier = create('Identifier') as formularId,
                    formularId.system = 'http://uk-koeln.de/NamingSystem/nNGM/formularId',
                    formularId.value = evaluate(index, '$this.formIndex.toString()');
            };   
            src then IncrementFormIndex(src, index);
        };  
    };
}

// Helper functions
group InitCaseIndex(source src: CTS_Transport, target index: RepeatIndex)
{
    src -> index.caseIndex = 1;
}

group IncrementCaseIndex(source src: CTS_Transport, target index: RepeatIndex)
{
    src -> index.caseIndex = evaluate(index, '$this.caseIndex + 1');
}

group InitFormIndex(source src: CTS_Transport, target index: RepeatIndex)
{
    src -> index.formIndex = 1;
}

group IncrementFormIndex(source src: CTS_Transport, target index: RepeatIndex)
{
    src -> index.formIndex = evaluate(index, '$this.formIndex + 1');
}

group InitSectionIndex(source src: BackboneElement, target index: RepeatIndex)
{
    src -> index.sectionIndex = 0;
}

group IncrementSectionIndex(source src: BackboneElement, target index: RepeatIndex)
{
    src -> index.sectionIndex = evaluate(index, '$this.sectionIndex + 1');
}

/*  InitMaxIndex: 
    The main idea is to search through the CDS export and find the highest formIndex to let our loops run until this maximum.
    To get this maxIndex, we look at the crfid of each form (e.g. 1-AF1, 1-AF2,..2-AF1,..) and try to isolate the number after the letters.
    This could easily be done by using a regex like \d+-[A-Z]+ in combination with a FHIRPath function like replaceMatches() for all forms.
    But I wasn't able to get this function working. So I used the following workaround on each form, for instance for Anforderung (AF):
        1. get the starting position of '-AF', add the length of this string '-AF' to get the starting position of the formIndex
            if this formIndex is bigger than the current maxIndex, 
        2. assign it to the maxIndex via evaluate() (therefore we need to create the same substring again)
*/
group InitMaxIndexAntrag(source src: CTS_Transport, target index: RepeatIndex)
{
    // Create this let because we can't check on two parameters with the same name in FHIRPath
    let caseIndex = evaluate(index, '$this.caseIndex');

    // init maxIndex, then find maxFormIndex
    src -> index.maxIndex = 1;

    // Anforderung
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-AF') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-AF\') + \'-AF\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-AF\') + \'-AF\'.length()).toInteger()');
    };

    // TNM
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-TNM') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-TNM\') + \'-TNM\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-TNM\') + \'-TNM\'.length()).toInteger()');
    };

    // Resistenztestung
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-RT') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-RT\') + \'-RT\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-RT\') + \'-RT\'.length()).toInteger()');
    };

    // Vorbefund
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-VB') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-VB\') + \'-VB\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-VB\') + \'-VB\'.length()).toInteger()');
    };
}

group InitMaxIndexBefund(source src: CTS_Transport, target index: RepeatIndex)
{
    // Create this let because we can't check on two parameters with the same name in FHIRPath
    let caseIndex = evaluate(index, '$this.caseIndex');

    // init maxIndex, then find maxFormIndex
    src -> index.maxIndex = 1;

    // Histologie
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-HL') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-HL\') + \'-HL\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-HL\') + \'-HL\'.length()).toInteger()');
    };

    // Immunhistochemie
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-IHC') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-IHC\') + \'-IHC\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-IHC\') + \'-IHC\'.length()).toInteger()');
    };

    // NGS Lung Panel
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-LP') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-LP\') + \'-LP\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-LP\') + \'-LP\'.length()).toInteger()');
    };

    // Molekularpathologie
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-MP') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-MP\') + \'-MP\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-MP\') + \'-MP\'.length()).toInteger()');
    };

    // Fusion NGS
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-FS') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-FS\') + \'-FS\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-FS\') + \'-FS\'.length()).toInteger()');
    };

    // Fast Track
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-FT') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-FT\') + \'-FT\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-FT\') + \'-FT\'.length()).toInteger()');
    };

    // Sonstige Untersuchungen
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-SU') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-SU\') + \'-SU\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-SU\') + \'-SU\'.length()).toInteger()');
    };

    // Liquid Biopsy
    src.operations as operations, operations where "crfid.contains(%caseIndex.toString() + '-LB') and type = 'save'  and data.exists()" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'-LB\') + \'-LB\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'-LB\') + \'-LB\'.length()).toInteger()');
    };
}

group InitMaxIndexTNM(source src: CTS_Transport, target index: RepeatIndex)
{
    // init maxIndex, then find maxFormIndex
    src -> index.maxIndex = 1;

    // TNM
    src.operations as operations, operations where "crfid.contains('TNM') and crfid.contains('-').not() and type = 'save'" then
    {
        // isolate formIndex from crfid, if this formIndex is bigger than maxIndex: assign it to maxIndex
        operations where "crfid.substring($this.crfid.indexOf(\'TNM\') + \'TNM\'.length()).toInteger() > %index.maxIndex"
            -> index.maxIndex = evaluate(operations, '$this.crfid.substring($this.crfid.indexOf(\'TNM\') + \'TNM\'.length()).toInteger()');
    };
}

group InitFormIndex(source src: CTS_Transport, target index: RepeatIndex)
{
    src -> index.formIndex = 1;
}

group IncrementFormIndex(source src: CTS_Transport, target index: RepeatIndex)
{
    src -> index.formIndex = evaluate(index, '$this.formIndex + 1');
}

group InitSectionIndex(source src: BackboneElement, target index: RepeatIndex)
{
    src -> index.sectionIndex = 0;
}

group IncrementSectionIndex(source src: BackboneElement, target index: RepeatIndex)
{
    src -> index.sectionIndex = evaluate(index, '$this.sectionIndex + 1');
}

group SetBooleanToFalse(source src: BackboneElement, target boolean: Boolean)
{
    src -> boolean.valueBoolean = false;
}

group SetBooleanToTrue(source src: BackboneElement, target boolean: Boolean)
{
    src -> boolean.valueBoolean = true;
}

// Get the Specimen referenced in composition:antrag.section:biopsy.section:anforderung and set reference to it
group SetReferenceToAnforderungSpecimen(source src: Bundle, source bundleBefund: Bundle, target compositionBefund: Composition, target diagnosticSection: BackboneElement)
{
    // find antragComposition according to fallnummer (of current compositionBefund)
    src.entry as srcEntry, srcEntry.resource as bundle, bundle.entry as bundleEntry, 
        bundleEntry.resource as antragComposition, antragComposition where "meta.profile = 'http://uk-koeln.de/fhir/StructureDefinition/Composition/nNGM/Antrag-pseudonymisiert' 
                                                    and identifier.where(system = 'http://uk-koeln.de/NamingSystem/nNGM/fallnummer' 
                                                                        and value = %compositionBefund.identifier.where(system = 'http://uk-koeln.de/NamingSystem/nNGM/fallnummer').value)" then
    {
        // find biopsySection according to formularId (of current diagnosticSection)
        antragComposition.section as biopsySection, biopsySection where "code.coding.where(system = 'http://uk-koeln.de/fhir/CodeSystem/nngm/sections' and code = 'biopsie')
                                                                            and entry.identifier.where(system = 'http://uk-koeln.de/NamingSystem/nNGM/formularId' 
                                                                                and value = %diagnosticSection.entry.identifier.where(system = 'http://uk-koeln.de/NamingSystem/nNGM/formularId').value)" then
        {
            // find anforderungSection
            biopsySection.section as anforderungSection, anforderungSection where "code.coding.where(system = 'http://uk-koeln.de/fhir/CodeSystem/nngm/sections' and code = 'anforderung')" then
            {
                // get reference of Specimen
                anforderungSection.entry as entry, entry.reference as specimenReference where "reference.contains('Specimen')" then
                {
                    // get last added nestedSection
                    diagnosticSection.section as currentSection where "section.last()" then
                    {
                        // get all Observations from this section
                        currentSection.entry as sectionEntry, sectionEntry.reference as sectionReference, bundleBefund.entry as entry, entry.resource as observation where "resource is Observation and resource.id = %sectionReference.split(\'/\').last()" then
                        {
                            // create Reference and set to Specimen
                            src then CreateObservationReferenceToSpecimen(specimenReference, observation);
                        }; 

                        // get all DiagnosticReports from this section
                        currentSection.entry as sectionEntry, sectionEntry.reference as sectionReference, bundleBefund.entry as entry, entry.resource as diagnosticReport where "resource is DiagnosticReport and resource.id = %sectionReference.split(\'/\').last()" then
                        {
                            // create Reference and set to Specimen
                            src then CreateDiagnosticReportReferenceToSpecimen(specimenReference, diagnosticReport);
                        }; 
                    };
                };
            };
        };
    };
}

// create Reference and set to Specimen
group CreateObservationReferenceToSpecimen(source specimenReference: string, target observation: Observation)
{
    specimenReference -> observation.specimen = create('Reference') as specimen, specimen.reference = evaluate(specimenReference, '\'Specimen/\' + $this.split(\'/\').last()');
}

group CreateDiagnosticReportReferenceToSpecimen(source specimenReference: string, target diagnosticReport: DiagnosticReport)
{
    specimenReference -> diagnosticReport.specimen = create('Reference') as specimen, specimen.reference = evaluate(specimenReference, '\'Specimen/\' + $this.split(\'/\').last()');
}